{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"findNeedles Method A reference document for a method that finds a set of words inside a text, and displays how many times it finds a match for each word. Syntax The following code sample represents a find needles in haystack method written in Java : public static void findNeedles(String haystack, String[] needles) { if (needles.length > 5) { System.err.println(\"Too many words!\"); } else { int[] countArray = new int[needles.length]; for (int i = 0; i<needles.length; i++) { String[] words = haystack.split(\"[ \\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } for (int j = 0; j<needles.length; j++) { System.out.println(needles[j] + \": \" + countArray[j]); } } } Parameters The method receives two parameters: public static void findNeedles(String haystack, String[] needles) haystack : the string containing the available words needles : the words to find in the haystack Execution Condition This method only works for a set of a maximum of five words . If the needles array contains more than five elements, an error message is displayed. if (needles.length > 5) { System.err.println(\"Too many words!\"); Haystack Split and Word Comparison If the condition allows, the method creates an array to store the count of each of the words in needles . else { int[] countArray = new int[needles.length]; The following for loop separates the haystack string into single words using the split Java method and stores them in a new array of strings called words . for (int i = 0; i<needles.length; i++) { String[] words = haystack.split(\"[ \\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } The split method takes two arguments: a regular expression and a limit . In this case: \"[\\\"\\'\\t\\n\\b\\f\\r]\" : This regular expression separates words from the text when it finds double quotes , single quotes , tabs , blank spaces , and line breaks . 0 : The 0 limit means that splitting will happen as many times as needed. Note: To know more about the split method, visit the String Class documentation and navigate to the split section. The inner for loop compares, using the compareTo Java method, each string of the words array with the word in the current position of the needles array. for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } For each comparison, the code checks if the compareTo method returned a 0 , indicating a match between both words. If there is a match, it increases the counter for that word. Note: To know more about the compareTo method, visit the Comparable documentation . Calling the Method and Displaying the Output Calling the method returns each word in needles and the number of times that it was found inside the haystack string. Here is an example of calling the method: String[] needles = new String[]{\"hello\",\"hollo\",\"hullo\", \"hillo\", \"hallo\"}; findNeedles(\"hello\\'hello\\thello\\bwhole'\\nhullo'hullo hillo\", needles); Which returns the following: hello: 3 hollo: 0 hullo: 2 hillo: 1 hallo: 0 Questions and Feedback If I were to ask the developer about the code, these are the questions I would ask: Why is it limited to only five words? Can it be implemented more generally, for example, use it also for numbers? Is there an easier regular expression to split the text? If I were to make suggestions, I would start with something positive and then move to the feedback. Something like this: Hi, \"Developer\" I reviewed the code and documented its reference material. Although I find it easy to understand and well structured, I noticed a couple of ways to improve it. Here are my thoughts: Take the words array declaration outside of the loop. In this way, the array will only be created once instead of in every iteration, saving memory. Declare only one counter instead of an array of counters. You can do it before looping and set it back to 0 after each needle comparison. Here is how the code would look like with the suggestions: public static void findNeedles(String haystack, String[] needles) { if (needles.length > 5) { System.err.println(\"Too many words!\"); } else { int count = 0; String[] words = haystack.split(\"[\\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int i = 0; i < needles.length; i++) { for (int j = 0; j < words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { count++; } } System.out.println(needles[i] + \": \" + count); count = 0; } } }","title":"Exercise 1 \u2014 findNeedles"},{"location":"#findneedles-method","text":"A reference document for a method that finds a set of words inside a text, and displays how many times it finds a match for each word.","title":"findNeedles Method"},{"location":"#syntax","text":"The following code sample represents a find needles in haystack method written in Java : public static void findNeedles(String haystack, String[] needles) { if (needles.length > 5) { System.err.println(\"Too many words!\"); } else { int[] countArray = new int[needles.length]; for (int i = 0; i<needles.length; i++) { String[] words = haystack.split(\"[ \\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } for (int j = 0; j<needles.length; j++) { System.out.println(needles[j] + \": \" + countArray[j]); } } }","title":"Syntax"},{"location":"#parameters","text":"The method receives two parameters: public static void findNeedles(String haystack, String[] needles) haystack : the string containing the available words needles : the words to find in the haystack","title":"Parameters"},{"location":"#execution-condition","text":"This method only works for a set of a maximum of five words . If the needles array contains more than five elements, an error message is displayed. if (needles.length > 5) { System.err.println(\"Too many words!\");","title":"Execution Condition"},{"location":"#haystack-split-and-word-comparison","text":"If the condition allows, the method creates an array to store the count of each of the words in needles . else { int[] countArray = new int[needles.length]; The following for loop separates the haystack string into single words using the split Java method and stores them in a new array of strings called words . for (int i = 0; i<needles.length; i++) { String[] words = haystack.split(\"[ \\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } The split method takes two arguments: a regular expression and a limit . In this case: \"[\\\"\\'\\t\\n\\b\\f\\r]\" : This regular expression separates words from the text when it finds double quotes , single quotes , tabs , blank spaces , and line breaks . 0 : The 0 limit means that splitting will happen as many times as needed. Note: To know more about the split method, visit the String Class documentation and navigate to the split section. The inner for loop compares, using the compareTo Java method, each string of the words array with the word in the current position of the needles array. for (int j = 0; j<words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { countArray[i]++; } } } For each comparison, the code checks if the compareTo method returned a 0 , indicating a match between both words. If there is a match, it increases the counter for that word. Note: To know more about the compareTo method, visit the Comparable documentation .","title":"Haystack Split and Word Comparison"},{"location":"#calling-the-method-and-displaying-the-output","text":"Calling the method returns each word in needles and the number of times that it was found inside the haystack string. Here is an example of calling the method: String[] needles = new String[]{\"hello\",\"hollo\",\"hullo\", \"hillo\", \"hallo\"}; findNeedles(\"hello\\'hello\\thello\\bwhole'\\nhullo'hullo hillo\", needles); Which returns the following: hello: 3 hollo: 0 hullo: 2 hillo: 1 hallo: 0","title":"Calling the Method and Displaying the Output"},{"location":"#questions-and-feedback","text":"If I were to ask the developer about the code, these are the questions I would ask: Why is it limited to only five words? Can it be implemented more generally, for example, use it also for numbers? Is there an easier regular expression to split the text? If I were to make suggestions, I would start with something positive and then move to the feedback. Something like this: Hi, \"Developer\" I reviewed the code and documented its reference material. Although I find it easy to understand and well structured, I noticed a couple of ways to improve it. Here are my thoughts: Take the words array declaration outside of the loop. In this way, the array will only be created once instead of in every iteration, saving memory. Declare only one counter instead of an array of counters. You can do it before looping and set it back to 0 after each needle comparison. Here is how the code would look like with the suggestions: public static void findNeedles(String haystack, String[] needles) { if (needles.length > 5) { System.err.println(\"Too many words!\"); } else { int count = 0; String[] words = haystack.split(\"[\\\"\\'\\t\\n\\b\\f\\r]\", 0); for (int i = 0; i < needles.length; i++) { for (int j = 0; j < words.length; j++) { if (words[j].compareTo(needles[i]) == 0) { count++; } } System.out.println(needles[i] + \": \" + count); count = 0; } } }","title":"Questions and Feedback"},{"location":"about/","text":"About page Wizeline DocOps template","title":"About page"},{"location":"about/#about-page","text":"","title":"About page"},{"location":"about/#wizeline-docops-template","text":"","title":"Wizeline DocOps template"},{"location":"exercise2/","text":"This section presents a brief description of the game Tic-Tac-Toe and the instructions to play it. Audience The document is aimed at people that do not know how to play the game. Tic-Tac-Toe Description Tic-Tac-Toe is a game designed for two players . It consists of a nine-space (3x3) grid where the players need to fill three consecutive symbols, Xs for one player and Os for the other. The first player to complete the sequence wins the game. Instructions There are some rules to consider when playing Tic-Tac-Toe. Players must: choose and use only one symbol per game mark once per turn mark only on blank spaces To play Tic-Tac-Toe: The first player marks one of the spaces with their selected symbol. The second player marks one of the remaining blank spaces. Repeat steps one and two until one of the players marks three consecutive spaces. The sequence can be one of the following options: Horizontal Vertical Diagonal","title":"Exercise 2b \u2014 How to Play Tic-Tac-Toe"},{"location":"exercise2/#audience","text":"The document is aimed at people that do not know how to play the game.","title":"Audience"},{"location":"exercise2/#tic-tac-toe-description","text":"Tic-Tac-Toe is a game designed for two players . It consists of a nine-space (3x3) grid where the players need to fill three consecutive symbols, Xs for one player and Os for the other. The first player to complete the sequence wins the game.","title":"Tic-Tac-Toe Description"},{"location":"exercise2/#instructions","text":"There are some rules to consider when playing Tic-Tac-Toe. Players must: choose and use only one symbol per game mark once per turn mark only on blank spaces To play Tic-Tac-Toe: The first player marks one of the spaces with their selected symbol. The second player marks one of the remaining blank spaces. Repeat steps one and two until one of the players marks three consecutive spaces. The sequence can be one of the following options: Horizontal Vertical Diagonal","title":"Instructions"},{"location":"exercise2b/","text":"This section presents the main differences between the Representational State Transfer (REST) and the Simple Object Access Protocol (SOAP) web services. REST and SOAP are two of the most used web services nowadays. Both provide a communication channel between clients and servers over the internet. The following table lists the main differences between REST and SOAP: Topic REST SOAP Style REST is an architectural style , meaning that there are principles to design a REST-like web service, not rules. SOAP is a protocol , meaning that there are guidelines to follow for communicating data. Communication Protocols It uses the HTTP protocol to request and retrieve data. It can use HTTP , SMTP , or FTP protocols. Communication Formats The most popular are XML and JSON formats. It uses XML messaging format between the client and the server. It contains a SOAP Envelop with a header, a body, and a fault element for errors. Data cached Can cache data Cannot cache data Security Supports HTTPS and SSL . Built-in standard such as WS-Security in addition to SSL support. Transactions Data-driven. It accesses a resource and requests, stores, or modifies data. SOAP performs operations such as transferring structured information. Performance Message size is considerably lesser than SOAP messages, making REST faster to transmit data. SOAP requires more bandwidth and resources, making it slower than REST. REST or SOAP Even though REST proves to have lighter payloads and faster responses, SOAP integrates security and reliability. You can use SOAP for: banking financial applications telecommunication services sensible, historical information REST can work better for performance-driven projects, such as: mobile services chats lightweight web services scalable and flexible applications","title":"Exercise 2a \u2014 Explaining Concepts"},{"location":"exercise2b/#rest-or-soap","text":"Even though REST proves to have lighter payloads and faster responses, SOAP integrates security and reliability. You can use SOAP for: banking financial applications telecommunication services sensible, historical information REST can work better for performance-driven projects, such as: mobile services chats lightweight web services scalable and flexible applications","title":"REST or SOAP"}]}